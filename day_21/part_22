import csv
import numpy as np
from tqdm import tqdm

def load_data(filename):
    code = []
    with open(filename, 'r') as file:
        csv_file = csv.reader(file)

        for row in csv_file:
            code.append(row[0])

    return code

def code_to_numpy_array(code):
    array = np.array(10)
    for i in range(0, len(code)):
        if code[i:i+1] == "A":
            array = np.append(array, 10)
        else:
            array = np.append(array, int(code[i:i+1]))

    return array

def numerical_options():
    return np.asarray([
        [[0, 2], [[1,10]]], 
        [[2, 9], [[1,1,2,10], [1,2,1,10], [2,1,1,10]]], 
        [[9, 10], [[3,3,3,10]]], 
        [[9, 8], [[4,10]]], 
        [[8, 0], [[3,3,3,10]]], 
        [[0, 10], [[2,10]]], 
        [[1, 7], [[1,1,10]]], 
        [[7, 9], [[2,2,10]]], 
        [[4, 5], [[2,10]]], 
        [[5, 6], [[2,10]]], 
        [[6, 10], [[3,3,10]]], 
        [[3, 7], [[4,4,1,1,10], [4,1,4,1,10], [1,4,1,4,10], [1,1,4,4,10]]],
        [[3, 4], [[4,4,1,10], [4,1,4,10], [1,4,4,10]]], 
        [[4, 0], [[2,3,3,10], [3,2,3,10]]], 
        [[1, 4], [[1,10]]], 
        [[4, 9], [[1,2,2,10], [2,1,2,10], [2,2,1,10]]], 
        [[5, 8], [[1,10]]], 
        [[8, 2], [[3,3,10]]], 
        [[2, 10], [[2,3,10], [3,2,10]]], 
        [[7, 8], [[2,10]]], 
        [[4, 6], [[2,2,10]]], 
        [[6, 3], [[3,10]]], 
        [[3, 10], [[3,10]]],
        [[10, 0], [[4,10]]],
        [[10, 1], [[4,1,4,10], [1,4,4,10]]],
        [[10, 3], [[1,10]]],
        [[10, 4], [[4,1,4,1,10], [4,1,1,4,10], [1,4,4,1,10], [1,4,1,4,10], [1,1,4,4,10]]],
        [[10, 5], [[4,1,1,10], [1,1,4,10], [1,4,1,10]]],
        [[10, 7], [[4,1,4,1,1,10], [4,1,1,4,1,10], [4,1,1,1,4,10], [1,4,4,1,1,10], [1,4,1,4,1,10], [1,4,1,1,4,10], [1,1,4,4,1,10], [1,1,4,1,4,10], [1,1,1,4,4,10]]],
        [[10, 9], [[1,1,1,10]]]
    ], dtype="object")
 
def make_directional_keypad():
    return [
        [1, [0,1]],
        [10, [0,2]],
        [4, [1,0]],
        [3, [1,1]],
        [2, [1,2]]
    ]

def directional_options():
    return np.asarray([
        [[1, 10], [[2,10]]], 
        [[1, 4], [[3,4,10]]], 
        [[1, 3], [[3,10]]], 
        [[1, 2], [[3,2,10], [2,3,10]]], 
        [[1, 1], [[10]]],
        [[10, 1], [[4,10]]], 
        [[10, 4], [[4,3,4,10], [3,4,4,10]]], 
        [[10, 3], [[4,3,10], [3,4,10]]], 
        [[10, 2], [[3,10]]], 
        [[10, 10], [[10]]],
        [[4, 1], [[2,1,10]]], 
        [[4, 10], [[2,2,1,10], [2,1,2,10]]], 
        [[4, 3], [[2,10]]], 
        [[4, 2], [[2,2,10]]], 
        [[4, 4], [[10]]],
        [[3, 1], [[1,10]]], 
        [[3, 10], [[1,2,10], [2,1,10]]], 
        [[3, 4], [[4,10]]], 
        [[3, 2], [[2,10]]], 
        [[3, 3], [[10]]],
        [[2, 1], [[4,1,10], [1,4,10]]], 
        [[2, 10], [[1,10]]], 
        [[2, 4], [[4,4,10]]], 
        [[2, 3], [[4,10]]],
        [[2, 2], [[10]]]
    ], dtype="object")

def find_new_sequences(number_from, number_to, options):
    for k in options:
        if number_from == k[0][0] and number_to == k[0][1]:
            return k[1]

def find_directional_sequences(sequences, numerical_option, directional_option, number_of_recursions, total_number_of_recursions):
    if number_of_recursions > 10:
        print(number_of_recursions)
    if number_of_recursions == total_number_of_recursions:
        complexity = []
        with tqdm(total=4) as pbar:
            for i in sequences:
                array = code_to_numpy_array(i)
                pbar.update(1)
                lengths = []                
                for j in range(0, len(array) - 1):
                    new_sequences = find_new_sequences(array[j], array[j+1], numerical_option)
                    lengths.append(find_directional_sequences(new_sequences, numerical_option, directional_option, number_of_recursions - 1, total_number_of_recursions))
                    # print(f"at the highest level {number_of_recursions} for sequence {i} the lengths are = {lengths} --------------------------")

                complexity.append(sum(lengths) * int(i[0:-1]))
            return complexity

    elif number_of_recursions > 0:
        if number_of_recursions > 10:
            print(f"the number of recursions is {number_of_recursions} and the length is {len(sequences)}")
        sum_lengths = None
        for k in sequences:
            k = np.append(10, k)
            lengths = []                
            for m in range(0, len(k) - 1):
                # print(k, k[m], k[m+1])
                new_sequences = find_new_sequences(k[m], k[m+1], directional_option)
                lengths.append(find_directional_sequences(new_sequences, numerical_option, directional_option, number_of_recursions - 1, total_number_of_recursions))
            if sum_lengths is None:
                sum_lengths = sum(lengths)
            else:
                if sum(lengths) < sum_lengths:
                    sum_lengths = sum(lengths)
            # print(f"at level {number_of_recursions} for sequence {k} the sum lengths = {sum_lengths} --------------------------")
        
        return sum_lengths

    else:
        sum_lengths_final = None
        # print(sequences)
        for n in sequences:
            n = np.append(10, n)
            lengths_final = []
            for o in range(0, len(n) - 1):
                # print(n[o], n[o+1])
                final_sequence = find_new_sequences(n[o], n[o+1], directional_option)

                # print(final_sequence)
                length = len(final_sequence[0])
                for p in final_sequence:
                    if len(p) < length:
                        length = len(p)
                lengths_final.append(length)

            if sum_lengths_final is None:
                sum_lengths_final = sum(lengths_final)
            else:
                if sum(lengths_final) < sum_lengths_final:
                    sum_lengths_final = sum(lengths_final)

        # print(f"the sequence is {n}, the sum of lengths = {sum_lengths_final}")

        return sum_lengths_final


def main():
    codes = load_data("input.csv")
    numerical_option = numerical_options()
    directional_option = directional_options()
    nr_recursions = 23
        
    complexity = find_directional_sequences(codes, numerical_option, directional_option, nr_recursions, nr_recursions)

    print(sum(complexity))

main()